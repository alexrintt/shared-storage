{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Check out pub.dev/shared_storage</p>"},{"location":"#stability","title":"Stability","text":"<p>The latest version is a Beta release, which means all these APIs can change over a short period of time without prior notice.</p> <p>So, please be aware that this is plugin is not intended for production usage yet, since the API is currently in development.</p>"},{"location":"#features","title":"Features","text":"<p>Current supported features are detailed below.</p>"},{"location":"#summary","title":"Summary","text":"<ul> <li> Read and write to files.</li> <li> Pick files using a filter (e.g image/png).</li> <li> Single or multiple file picks.</li> <li> Picking directories.</li> <li> Load file data immediately into memory (Uint8List) if needed.</li> <li> Delete files/directories.</li> <li> Getting file thumbnails as <code>Image.memory</code> bytes (Uint8List).</li> <li> Launch file with third apps.</li> <li> Request install APKs.</li> <li> List directory contents recursively (aka file-explorer like experience).</li> </ul>"},{"location":"#detailed","title":"Detailed","text":"<ul> <li> No runtime permissions are required, this package doesn't rely on <code>MANAGE_EXTERNAL_STORAGE</code> or any other runtime permission, only normal permissions (<code>READ_EXTERNAL_STORAGE</code>, <code>WRITE_EXTERNAL_STORAGE</code>) are implicitly used and added to your Android project.</li> <li> Read file content as Future.</li> <li> Read file content as Stream (planned).</li> <li> Get file's thumbnail (APK file icons are also supported but not recommended due it's poor performance limited by SAF and PackageManager API).</li> <li> Request install apk (requires <code>REQUEST_INSTALL_PACKAGE</code> permission and it's entirely optional).</li> <li> Open and persist folders granted by the user (\"Select folder\" use-case).</li> <li> Open and persist files granted by the user (\"Select file\" use-case).</li> <li> Different default type filtering (media, image, video, audio or any).</li> <li> List files inside a folder with Streams.</li> <li> Copy file.</li> <li> Open file with third-party apps (aka \"Open with\" use-case).</li> <li> Folders and files granted can be persisted across device reboots (optional).</li> <li> Delete file.</li> <li> Delete folder.</li> <li> Edit file contents.</li> <li> Edit file contents through lazy streams (planned).</li> <li> Move file (it's a copy + delete).</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Use latest version when installing this plugin:</p> <pre><code>flutter pub add shared_storage\n</code></pre> <p>or</p> <pre><code>dependencies:\nshared_storage: ^latest # Pickup the latest version either from the pub.dev page or doc badge\n</code></pre>"},{"location":"#plugin","title":"Plugin","text":"<p>This plugin include partial support for the following APIs:</p>"},{"location":"#partial-support-for-environment","title":"Partial Support for Environment","text":"<p>Mirror API from Environment</p> <pre><code>import 'package:shared_storage/environment.dart' as environment;\n</code></pre>"},{"location":"#partial-support-for-media-store","title":"Partial Support for Media Store","text":"<p>Mirror API from MediaStore provider</p> <pre><code>import 'package:shared_storage/media_store.dart' as mediastore;\n</code></pre>"},{"location":"#partial-support-for-storage-access-framework","title":"Partial Support for Storage Access Framework","text":"<p>Mirror API from Storage Access Framework</p> <pre><code>import 'package:shared_storage/saf.dart' as saf;\n</code></pre> <p>All these APIs are module based, which means they are implemented separadely and so you need to import those you want use.</p> <p>To request support for some API that is not currently included open a issue explaining your usecase and the API you want to make available, the same applies for new methods or activities for the current APIs.</p>"},{"location":"#contribute","title":"Contribute","text":"<p>If you have ideas to share, bugs to report or need support, you can open an issue.</p>"},{"location":"#android-apis","title":"Android APIs","text":"<p>Most Flutter plugins use Android API's under the hood. So this plugin does the same, and to call native Android storage APIs the following API's are being used:</p> <p><code>\ud83d\udd17android.os.Environment</code> <code>\ud83d\udd17android.provider.MediaStore</code> <code>\ud83d\udd17android.provider.DocumentsProvider</code></p>"},{"location":"#supporters","title":"Supporters","text":"<ul> <li>aplicatii-romanesti who bought me a whole month of caffeine!</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>honjow contributed by implementing <code>openDocument</code> Android API #110 to pick single or multiple file URIs. Really helpful, thanks!</li> <li>clragon submitted a severe bug report #107 and opened discussions around package architecture #108, thanks!</li> <li>jfaltis fixed a memory leak #86 and implemented an API to override existing files #85, thanks for your contribution!</li> <li>EternityForest did report a severe crash #50 when the column ID was not provided and implemented a new feature to list all subfolders #59, thanks man!</li> <li>Thanks dhaval-k-simformsolutions for taking time to submit bug reports related to duplicated file entries!</li> <li>dangilbert pointed and fixed a bug #14 when the user doesn't select a folder, thanks man!</li> <li>A huge thanks to aplicatii-romanesti for taking time to submit device specific issues!</li> <li>I would thanks ankitparmar007 for discussing and requesting create file related APIs #20!</li> </ul>"},{"location":"Contributing/Ways%20to%20contribute/","title":"Ways to contribute","text":""},{"location":"Contributing/Ways%20to%20contribute/#how-can-i-contribute","title":"How can I contribute?","text":"<p>Code is not the only thing matters when we talk about packages and open-source libraries, there's a lot of another tasks which are equally important:</p> <ul> <li>Reporting bugs.</li> <li>Creating show-cases.</li> <li>Improving documentation.</li> <li>Asking questions.</li> <li>Answering questions.</li> <li>Sharing ideas.</li> <li>Reporting usage issues (Something looks wrong on API?).</li> </ul>"},{"location":"Contributing/Setup%20environment/Debugging%20plugin/","title":"Debugging plugin","text":"<p>First you need follow the guide <code>Setup local environment</code> in order to read this guide</p> <p>Since this is an Android plugin, you'll need to use Android Studio in order to have a full intellisense and debugging features for Kotlin.</p> <p>You can also use Visual Studio Code for Dart and Android Studio for Kotlin.</p>"},{"location":"Contributing/Setup%20environment/Debugging%20plugin/#android-side","title":"Android Side","text":"<p>All android plugin is inside <code>/android</code> folder.</p> <p>There a few steps in order to start debugging this plugin:</p> <ul> <li>Open the project inside Android Studio.</li> <li>Right click on <code>/android</code> folder.</li> <li><code>Flutter</code> &gt; <code>Open Android module in Android Studio</code> &gt; <code>New Window</code>.</li> </ul> <p>Done, all completing features will be available.</p> <p>See Flutter docs for details.</p>"},{"location":"Contributing/Setup%20environment/Debugging%20plugin/#dart-side","title":"Dart Side","text":"<p>There's no additional step. Just open the directory inside your preferable editor.</p> <p>Happy hacking.</p>"},{"location":"Contributing/Setup%20environment/Setup%20local%20environment/","title":"Setup local environment","text":"<p>If you already have Flutter configured you can skip this step</p>"},{"location":"Contributing/Setup%20environment/Setup%20local%20environment/#setting-up-your-local-environment","title":"Setting up your local environment","text":"<p>All you need is to make sure you can run Flutter apps in your machine from your shell, by <code>flutter run</code> inside your Flutter project as well you can also run your Flutter project inside Android Studio IDE. Since this IDE support Android process debugging.</p>"},{"location":"Contributing/Setup%20environment/Setup%20local%20environment/#configuring-flutter","title":"Configuring Flutter","text":"<p>You should configure your Flutter local environment properly. There's several online resources can help you do that as well the official documentation:</p> <ul> <li>Flutter Official documentation</li> <li>How to Install and Set Up Flutter on Ubuntu 16.04+</li> <li>Flutter \u2013 Installation on macOS</li> <li>How to Install Flutter on Windows?</li> </ul> <p>In summary: all you need to do is to setup Android plus the Flutter binaries available globally through your CLI interface.</p> <p>To ensure everything is working, type <code>flutter doctor</code> in your shell, you should see something like this:</p> <pre><code>Doctor summary (to see all details, run flutter doctor -v):\n[\u221a] Flutter (Channel stable, 2.10.0, on Microsoft Windows [Version 10.0.19043.1645], locale en-US)\n[\u221a] Android toolchain - develop for Android devices (Android SDK version 31.0.0)\n[\u221a] Chrome - develop for the web\n[\u221a] Visual Studio - develop for Windows (Visual Studio Build Tools 2019 16.11.13)\n[\u221a] Android Studio (version 2020.3)\n[\u221a] IntelliJ IDEA Community Edition (version 2021.3)\n[\u221a] Connected device (2 available)\n! Device RX8M40FQ3KF is offline.\n[\u221a] HTTP Host Availability\n\n\u2022 No issues found!\n</code></pre>"},{"location":"Migrate%20notes/Migrate%20to%20v0.3.0/","title":"Migrate to v0.3.0","text":"<p>There's some breaking changes from <code>v0.2.x</code> then be careful when updating on <code>pubspec.yaml</code></p> <p><code>pubspec.yaml</code> dependecy manager file:</p> <pre><code>dependencies:\nshared_storage: v0.3.0\n</code></pre>"},{"location":"Migrate%20notes/Migrate%20to%20v0.3.0/#sdk-constraint","title":"SDK constraint","text":"<p>In <code>android\\app\\build.gradle</code> set <code>android.defaultConfig.minSdkVersion</code> to <code>19</code>:</p> <pre><code>android {\n  ...\n  defaultConfig {\n    ...\n    minSdkVersion 19\n  }\n  ...\n}\n</code></pre>"},{"location":"Migrate%20notes/Migrate%20to%20v0.3.0/#plugin-import","title":"Plugin import","text":"<p>Although this import is still supported:</p> <pre><code>import 'package:shared_storage/shared_storage.dart' as shared_storage;\n</code></pre> <p>This should be renamed to any of them or all:</p> <pre><code>import 'package:shared_storage/saf.dart' as saf;\nimport 'package:shared_storage/media_store.dart' as media_store;\nimport 'package:shared_storage/environment.dart' as environment;\n</code></pre> <p>Choose which modules/imports one you want to include inside in your project.</p>"},{"location":"Migrate%20notes/Migrate%20to%20v0.3.0/#media-store-getmediastorecontentdirectory","title":"Media Store <code>getMediaStoreContentDirectory</code>","text":"<p>The method <code>getMediaStoreContentDirectory</code> now returns the right class <code>Uri</code> instead of a <code>Directory</code>.</p> <p>Be sure to update all ocurrences.</p> <p>This <code>Uri</code> is used to represent a directory.</p>"},{"location":"Migrate%20notes/Migrate%20to%20v0.5.0/","title":"Migrate to v0.5.0","text":"<p>There's major breaking changes when updating to <code>v0.5.0</code>, be careful.</p> <p>Update your <code>pubspec.yaml</code>:</p> <pre><code>dependencies:\nshared_storage: ^0.5.0\n</code></pre>"},{"location":"Migrate%20notes/Migrate%20to%20v0.5.0/#return-type-of-listfiles","title":"Return type of <code>listFiles</code>","text":"<p>Instead of:</p> <pre><code>Stream&lt;PartialDocumentFile&gt; fileStream = listFiles(uri);\n</code></pre> <p>use:</p> <pre><code>Stream&lt;DocumentFile&gt; fileStream = listFiles(uri);\n</code></pre> <p>And when reading data from each file:</p> <pre><code>// Old.\nPartialDocumentFile file = ...\n\nString displayName = file.data![DocumentFileColumn.displayName] as String;\nDateTime lastModified = DateTime.fromMillisecondsSinceEpoch(file.data![DocumentFileColumn.lastModified] as int);\n\n// New.\nDocumentFile file = ...\n\nString displayName = file.name;\nDateTime lastModified = file.lastModified;\n</code></pre> <p>It now parses all fields as class fields instead <code>Map&lt;DocumentFileColumn, dynamic&gt;</code> hash map.</p>"},{"location":"Migrate%20notes/Migrate%20to%20v0.6.0/","title":"Migrate to v0.6.0","text":"<p>There's major breaking changes when updating to <code>v0.6.0</code>, be careful.</p> <p>Update your <code>pubspec.yaml</code>:</p> <pre><code>dependencies:\nshared_storage: ^0.6.0\n</code></pre>"},{"location":"Migrate%20notes/Migrate%20to%20v0.6.0/#import-statement","title":"Import statement","text":"<p>Instead of:</p> <pre><code>import 'package:shared_storage/environment.dart' as environment;\nimport 'package:shared_storage/media_store.dart' as environment;\nimport 'package:shared_storage/saf.dart' as environment;\n</code></pre> <p>Import as:</p> <pre><code>import 'package:shared_storage/shared_storage' as shared_storage;\n</code></pre> <p>It's now has all APIs available under <code>shared_storage</code> key.</p>"},{"location":"Migrate%20notes/Migrate%20to%20v0.6.0/#getcontent-and-getcontentasstring","title":"<code>getContent()</code> and <code>getContentAsString()</code>","text":"<p>Wrongly the previous versions required an unused parameter called <code>destination</code>:</p> <pre><code>uri.getContentAsString(uri);\nuri.getContent(uri);\n</code></pre> <p>It now has been removed:</p> <pre><code>uri.getContentAsString();\nuri.getContent();\n</code></pre>"},{"location":"Migrate%20notes/Migrate%20to%20v0.7.0/","title":"Migrate to v0.7.0","text":"<p>There's no major breaking changes when updating to <code>v0.7.0</code> but there are deprecation notices if you are using Media Store and Environment API.</p> <p>Update your <code>pubspec.yaml</code>:</p> <pre><code>dependencies:\nshared_storage: ^0.7.0\n</code></pre>"},{"location":"Migrate%20notes/Migrate%20to%20v0.7.0/#deprecation-notices","title":"Deprecation notices","text":"<p>All non SAF APIs are deprecated, if you are using them, let us know by opening an issue with your use-case so we can implement a new compatible API using a cross-platform approach.</p>"},{"location":"Usage/API%20Labeling/","title":"API Labeling","text":""},{"location":"Usage/API%20Labeling/#warning","title":"Warning","text":"<p>This labeling will be removed soon, I it will be replaced with a full original API as described in #56.</p>"},{"location":"Usage/API%20Labeling/#labeling","title":"Labeling","text":"<p>When refering to the docs you'll usually see some labels before the method/class names.</p> <p>They are label which identifies where the API came from.</p> <p>This package is intended to be a mirror of native Android APIs. Which means all methods and classes are just a re-implementation of native APIs, but some places we can't do that due technical reasons. So we put a label to identify when it'll happen.</p> <p>You are fully encouraged to understand/learn the native Android APIs to use this package. All packages (not only this one) are derivated from native APIs depending on the platform (Windows, iOS, Android, Unix, Web, etc.), to have a understing about it can help not only here but on all your Flutter journey, and even in other frameworks.</p> Label Description Internal New internal type (class). Usually they are only to keep a safe typing and are not usually intended to be instantiated for the package user. Original Original API which only exists inside this package and doesn't mirror any Android API (an abstraction). Mirror Pure mirror API (method/class) which was re-implemented in Dart from a native original API. Alias Convenient methods. They do not implement anything new but create a new abstraction from an existing API. External API from third-part Android libraries. Extension These are most alias methods implemented through Dart extensions."},{"location":"Usage/Environment/","title":"Environment","text":"<p>WARNING This API is deprecated and will be removed soon. If you need it, please open an issue with your use-case to include in the next release as part of the new original cross-platform API.</p>"},{"location":"Usage/Environment/#import-package","title":"Import package","text":"<pre><code>import 'package:shared_storage/shared_storage.dart' as shared_storage;\n</code></pre> <p>Usage sample:</p> <pre><code>shared_storage.getRootDirectory(...);\nshared_storage.getExternalStoragePublicDirectory(...);\n</code></pre> <p>But if you import without alias <code>import '...';</code> (Not recommeded because can conflict with other method/package names) you should use directly as functions:</p> <pre><code>getRootDirectory(...);\ngetExternalStoragePublicDirectory(...);\n</code></pre>"},{"location":"Usage/Environment/#mirror-methods","title":"Mirror methods","text":"<p>Mirror methods are available to provide an way to call a native method without using any abstraction, available mirror methods:</p>"},{"location":"Usage/Environment/#getrootdirectory","title":"getRootDirectory","text":"<p>Mirror of <code>Environment.getRootDirectory</code></p> <p>Return root of the \"system\" partition holding the core Android OS. Always present and mounted read-only.</p> <p>Warning Some new Android versions return null because <code>SAF</code> is the new API to handle storage.</p> <pre><code>final Directory? rootDir = await getRootDirectory();\n</code></pre>"},{"location":"Usage/Environment/#getexternalstoragepublicdirectory","title":"getExternalStoragePublicDirectory","text":"<p>Mirror of <code>Environment.getExternalStoragePublicDirectory</code></p> <p>Get a top-level shared/external storage directory for placing files of a particular type. This is where the user will typically place and manage their own files, so you should be careful about what you put here to ensure you don't erase their files or get in the way of their own organization.</p> <p>Warning Some new Android versions return null because <code>SAF</code> is the new API to handle storage.</p> <pre><code>final Directory? externalPublicDir = await getExternalStoragePublicDirectory(EnvironmentDirectory.downloads);\n</code></pre>"},{"location":"Usage/Environment/#getexternalstoragedirectory","title":"getExternalStorageDirectory","text":"<p>Mirror of <code>Environment.getExternalStorageDirectory</code></p> <p>Return the primary shared/external storage directory. This directory may not currently be accessible if it has been mounted by the user on their computer, has been removed from the device, or some other problem has happened.</p> <p>Warning Some new Android versions return null because <code>SAF</code> is the new API to handle storage.</p> <pre><code>final Directory? externalDir = await getExternalStorageDirectory();\n</code></pre>"},{"location":"Usage/Environment/#getdatadirectory","title":"getDataDirectory","text":"<p>Mirror of <code>Environment.getDataDirectory</code></p> <p>Return the user data directory.</p> <p>Info What may not be obvious is that the \"user data directory\" returned by <code>Environment.getDataDirectory</code> is the system-wide data directory (i.e, typically so far <code>/data</code>) and not an application specific directory. Applications of course are not allowed to write to the overall data directory, but only to their particular folder inside it or other select locations whose owner has granted access. Reference by Chris Stratton</p> <p>Warning Some new Android versions return null because <code>SAF</code> is the new API to handle storage.</p> <pre><code>final Directory? dataDir = await getDataDirectory();\n</code></pre>"},{"location":"Usage/Environment/#getdownloadcachedirectory","title":"getDownloadCacheDirectory","text":"<p>Mirror of <code>Environment.getDownloadCacheDirectory</code></p> <p>Return the download/cache content directory.</p> <p>Typically the <code>/data/cache</code> directory.</p> <p>Warning Some new Android versions return null because <code>SAF</code> is the new API to handle storage.</p> <pre><code>final Directory? downloadCacheDir = await getDownloadCacheDirectory();\n</code></pre>"},{"location":"Usage/Environment/#getstoragedirectory","title":"getStorageDirectory","text":"<p>Mirror of <code>Environment.getStorageDirectory</code></p> <p>Return root directory where all external storage devices will be mounted. For example, <code>getExternalStorageDirectory()</code> will appear under this location.</p> <p>Warning Some new Android versions return null because <code>SAF</code> is the new API to handle storage.</p> <pre><code>final Directory? storageDir = await getStorageDirectory();\n</code></pre>"},{"location":"Usage/Environment/#android-official-documentation","title":"Android Official Documentation","text":"<p>The Environment official documentation is available here.</p> <p>All the APIs listed in this plugin module are derivated from the official docs.</p>"},{"location":"Usage/Media%20Store/","title":"Media Store","text":"<p>WARNING This API is deprecated and will be removed soon. If you need it, please open an issue with your use-case to include in the next release as part of the new original cross-platform API.</p>"},{"location":"Usage/Media%20Store/#import-package","title":"Import package","text":"<pre><code>import 'package:shared_storage/shared_storage.dart' as shared_storage;\n</code></pre> <p>Usage sample:</p> <pre><code>shared_storage.getMediaStoreContentDirectory(...);\n</code></pre> <p>But if you import without alias <code>import '...';</code> (Not recommeded because can conflict with other method/package names) you should use directly as functions:</p> <pre><code>getMediaStoreContentDirectory(...);\n</code></pre>"},{"location":"Usage/Media%20Store/#api-reference","title":"API reference","text":"<p>Original API. These methods exists only in this package.</p> <p>Because methods are an abstraction from native API, for example: <code>getMediaStoreContentDirectory</code> is an abstraction because there's no such method in native Android, there you can access these directories synchronously and directly from the <code>MediaStore</code> nested classes which is not the goal of this package (re-create all Android APIs) but provide a powerful fully-configurable API to call these APIs.</p>"},{"location":"Usage/Media%20Store/#getmediastorecontentdirectory","title":"getMediaStoreContentDirectory","text":"<p>Get the directory of a given Media Store Collection.</p> <p>The directory follows the Uri format</p> <p>To see all available collections see <code>MediaStoreCollection</code> class</p> <pre><code>final Uri directory = getMediaStoreContentDirectory(MediaStoreCollection.downloads);\n</code></pre>"},{"location":"Usage/Media%20Store/#android-official-documentation","title":"Android Official Documentation","text":"<p>The Media Store official documentation is available here.</p> <p>All the APIs listed in this plugin module are derivated from the official docs.</p>"},{"location":"Usage/Storage%20Access%20Framework/","title":"Storage Access Framework","text":""},{"location":"Usage/Storage%20Access%20Framework/#import-package","title":"Import package","text":"<pre><code>import 'package:shared_storage/shared_storage.dart' as saf;\n</code></pre> <p>Usage sample:</p> <pre><code>saf.openDocumentTree(...);\nsaf.listFiles(...);\n</code></pre> <p>But if you import without alias <code>import '...';</code> (Not recommeded because can conflict with other method/package names) you should use directly as functions:</p> <pre><code>openDocumentTree(...);\nlistFiles(...);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#example-project","title":"Example project","text":"<p>The example project does use of most of these APIs, that is available at <code>/example</code></p>"},{"location":"Usage/Storage%20Access%20Framework/#concepts","title":"Concepts","text":"<p>This is a brief explanation of the core concepts of this API.</p>"},{"location":"Usage/Storage%20Access%20Framework/#whats-an-uri","title":"What's an <code>Uri</code>?","text":"<p><code>Uri</code> is a the most confusing concept we can found. Since it's not a regular string, it's not a regular url, neither a regular file system path.</p> <p>By the official docs:</p> <p>A URI is a uniform resource identifier while a URL is a uniform resource locator. Hence every URL is a URI, abstractly speaking, but not every URI is a URL. This is because there is another subcategory of URIs, uniform resource names (URNs), which name resources but do not specify how to locate them. The mailto, news, and isbn URIs shown above are examples of URNs.</p> <p>Which translated means: this <code>Uri</code> can represent almost anything.</p> <p>Often this <code>Uri</code>s represent a folder or a file but not always. And different <code>Uri</code>s can point to the same file/folder</p>"},{"location":"Usage/Storage%20Access%20Framework/#permission-over-an-uri","title":"Permission over an <code>Uri</code>","text":"<p>To operate (read, delete, update, create) a file or folder within a directory, you need first to request permission of the user. These permissions are represented as <code>UriPermission</code>, reference.</p>"},{"location":"Usage/Storage%20Access%20Framework/#api-labeling","title":"API Labeling","text":"<p>See the label reference here.</p>"},{"location":"Usage/Storage%20Access%20Framework/#api-reference","title":"API reference","text":"<p>Original API. These methods exists only in this package.</p> <p>Because methods are an abstraction from native API, for example: <code>openDocumentTree</code> is an abstraction because there's no such method in native Android, there you need to create a intent and start an activity which is not the goal of this package (re-create all Android APIs) but provide a powerful fully-configurable API to call these APIs.</p>"},{"location":"Usage/Storage%20Access%20Framework/#opendocumenttree","title":"openDocumentTree","text":"<p>This API allows you grant <code>Uri</code>s permission by calling like this:</p> <pre><code>final Uri? grantedUri = await openDocumentTree();\n\nif (grantedUri != null) {\nprint('Now I have permission over this Uri: $grantedUri');\n}\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#opendocument","title":"openDocument","text":"<p>Same as <code>openDocumentTree</code> but for file URIs, you can request user to select a file and filter by:</p> <ul> <li>Single or multiple files.</li> <li>Mime type.</li> </ul> <p>You can also specify if you want a one-time operation (<code>persistablePermission</code> = false) and if you don't need write access (<code>grantWritePermission</code> = false).</p> <pre><code>const kDownloadsFolder =\n'content://com.android.externalstorage.documents/tree/primary%3ADownloads/document/primary%3ADownloads';\n\nfinal List&lt;Uri&gt;? selectedDocumentUris = await openDocument(\n// if you have a previously saved URI,\n// you can use the specify the tree you user will see at startup of the file picker.\ninitialUri: Uri.parse(kDownloadsFolder),\n\n// whether or not allow the user select multiple files.\nmultiple: true,\n\n// whether or not the selected URIs should be persisted across app and device reboots.\npersistablePermission: true,\n\n// whether or not grant write permission required to edit file metadata (name) and it's contents.\ngrantWritePermission: true,\n\n// whether or not filter by mime type.\nmimeType: 'image/*' // default '*/*'\n);\n\nif (selectedDocumentUris == null) {\nreturn print('User cancelled the operation.');\n}\n\n// If [selectedDocumentUris] are [persistablePermission]s then it will be returned by this function\n// along with any another URIs you've got permission over.\nfinal List&lt;UriPermission&gt; persistedUris = await persistedUriPermissions();\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#listfiles","title":"listFiles","text":"<p>This method list files lazily over a granted uri:</p> <p>Note <code>DocumentFileColumn.id</code> is optional. It is required to fetch the file list from native API. So it is enabled regardless if you include this column or not. And this applies only to this API (<code>listFiles</code>).</p> <pre><code>/// *Must* be a granted uri from `openDocumentTree`, or a URI representing a child under such a granted uri.\nfinal Uri myGrantedUri = ...\nfinal DocumentFile? documentFileOfMyGrantedUri = await myGrantedUri.toDocumentFile();\n\nif (documentFileOfMyGrantedUri == null) {\nreturn print('This is not a valid Uri permission or you do not have the permission');\n}\n\n/// Columns/Fields you want access. Android handle storage as database.\n/// Allow you specify only the fields you need to use, avoiding querying unnecessary data\nconst List&lt;DocumentFileColumn&gt; columns = &lt;DocumentFileColumn&gt;[\nDocumentFileColumn.displayName,\nDocumentFileColumn.size,\nDocumentFileColumn.lastModified,\nDocumentFileColumn.id, // Optional column, will be available/queried regardless if is or not included here\nDocumentFileColumn.mimeType,\n];\n\nfinal List&lt;DocumentFile&gt; files = [];\n\nfinal Stream&lt;DocumentFile&gt; onNewFileLoaded = documentFileOfMyGrantedUri.listFiles(columns);\n\nonNewFileLoaded.listen((file) =&gt; files.add(file), onDone: () =&gt; print('All files were loaded'));\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#opendocumentfile","title":"openDocumentFile","text":"<p>Open a file uri in a external app, by starting a new activity with <code>ACTION_VIEW</code> Intent.</p> <pre><code>final Uri fileUri = ...\n\n/// This call will prompt the user: \"Open with\" dialog\n/// Or will open directly in the app if this there's only a single app that can handle this file type.\nawait openDocumentFile(fileUri);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#getdocumentcontent","title":"getDocumentContent","text":"<p>Read a document file from its uri by opening a input stream and returning its bytes.</p> <pre><code>/// See also: [getDocumentContentAsString]\nfinal Uri uri = ...\n\nfinal Uint8List? fileContent = await getDocumentContent(uri);\n\n/// Handle [fileContent]...\n\n/// If the file is intended to be human readable, you can convert the output to [String]:\nprint(utf8.decode(fileContent));\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#getrealpathfromuri","title":"getRealPathFromUri","text":"<p>Helper method to generate the file path of the given <code>uri</code>. This returns the real path to work with native old <code>File</code> API instead Uris, be aware this approach is no longer supported on Android 10+ (API 29+) and though new, this API is marked as deprecated and should be migrated to a scoped-storage approach.</p> <p>See Get real path from URI, Android KitKat new storage access framework for details.</p> <pre><code>final Uri uri = ...;\n\nfinal String? filePath = await getRealPathFromUri(myUri);\n\nfinal File file = File(filePath);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#mirror-methods","title":"Mirror methods","text":"<p>Mirror methods are available to provide an way to call a native method without using any abstraction, available mirror methods:</p>"},{"location":"Usage/Storage%20Access%20Framework/#exists","title":"exists","text":"<p>Mirror of <code>DocumentFile.exists</code></p> <p>Returns <code>true</code> if a given <code>uri</code> exists.</p> <pre><code>final Uri uri = ...\n\nif (await exists(uri) ?? false) {\nprint('There is no granted Uris');\n} else {\nprint('My granted Uris: $grantedUris');\n}\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#persisteduripermissions","title":"persistedUriPermissions","text":"<p>Mirror of <code>ContentResolver.getPersistedUriPermissions</code></p> <p>Basically this allow get the granted <code>Uri</code>s permissions after the app restarts without the need of requesting the folders again.</p> <pre><code>final List&lt;UriPermission&gt;? grantedUris = await persistedUriPermissions();\n\nif (grantedUris == null) {\nprint('There is no granted Uris');\n} else {\nprint('My granted Uris: $grantedUris');\n}\n</code></pre> <p>From the official docs:</p> <p>Return list of all URI permission grants that have been persisted by the calling app. That is, the returned permissions have been granted to the calling app. Only persistable grants taken with <code>takePersistableUriPermission(android.net.Uri, int)</code> are returned. Note: Some of the returned URIs may not be usable until after the user is unlocked.</p>"},{"location":"Usage/Storage%20Access%20Framework/#releasepersistableuripermission","title":"releasePersistableUriPermission","text":"<p>Mirror of <code>ContentResolver.releasePersistableUriPermission</code></p> <p>Opposite of <code>openDocumentTree</code>. This method revoke all permissions you have under a specific <code>Uri</code>. This should be used to allow the user revoke the permission of <code>Uri</code>s inside your app without needing revoking at OS level.</p> <pre><code>final List&lt;UriPermission&gt; grantedUris = ...\n\n/// Revoke all granted Uris\nfor (final UriPermission uri of grantedUris) {\nawait releasePersistableUriPermission(uri);\n}\n\n/// You can also revoke a single Uri\nawait releasePersistableUriPermission(grantedUris[0]);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#createfileasbytes","title":"createFileAsBytes","text":"<p>Mirror of <code>DocumentFile.createFile</code></p> <p>Create a file using raw bytes <code>Uint8List</code>.</p> <p>Given the parent uri, creates a new child document file that represents a single file given the <code>displayName</code>, <code>mimeType</code> and its <code>content</code> in bytes (file name, file type and file content in raw bytes, respectively).</p> <pre><code>final Uri parentUri = ...\nfinal String fileContent = 'My File Content';\n\nfinal DocumentFile? createdFile = createFileAsBytes(\nparentUri,\nmimeType: 'text/plain',\ndisplayName: 'Sample File Name',\nbytes: Uint8List.fromList(utf8.encode(fileContent)),\n);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#writetofileasbytes","title":"writeToFileAsBytes","text":"<p>Write to a file using raw bytes <code>Uint8List</code>.</p> <p>Given the document uri, opens the file in the specified <code>mode</code> and writes the <code>bytes</code> to it.</p> <p><code>mode</code> represents the mode in which the file will be opened for writing. Use <code>FileMode.write</code> for truncating (overwrite) and <code>FileMode.append</code> for appending to the file.</p> <pre><code>final Uri documentUri = ...\nfinal String fileContent = 'My File Content';\n\n/// Write to a file using a [Uint8List] as file contents [bytes]\nfinal bool? success = writeToFileAsBytes(\ndocumentUri,\nbytes: Uint8List.fromList(utf8.encode(fileContent)),\nmode: FileMode.write,\n);\n\n/// Append to a file using a [Uint8List] as file contents [bytes]\nfinal bool? success = writeToFileAsBytes(\ndocumentUri,\nbytes: Uint8List.fromList(utf8.encode(fileContent)),\nmode: FileMode.write,\n);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#canread","title":"canRead","text":"<p>Mirror of <code>DocumentFile.canRead</code></p> <p>Returns <code>true</code> if the caller can read the given <code>uri</code>, that is, if has the properly permissions.</p> <pre><code>final Uri uri = ...\n\nif (await canRead(uri) ?? false) {\nprint('I have permissions to read $uri');\n\nfinal Uint8List? fileContent = await getDocumentContent(uri);\n\n/// ...\n} else {\nfinal UriPermission? permission = openDocumentTree(uri);\n\n/// ...\n}\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#canwrite","title":"canWrite","text":"<p>Mirror of <code>DocumentFile.canWrite</code></p> <p>Returns <code>true</code> if the caller can write the given <code>uri</code>, that is, if has the properly permissions.</p> <pre><code>final Uri uri = ...\n\nif (await canWrite(uri) ?? false) {\nprint('I have permissions to write $uri');\n\nfinal Uint8List? fileContent = await renameTo(uri, 'New File Name');\n\n/// ...\n} else {\nfinal UriPermission? permission = openDocumentTree(\nuri,\ngrantWritePermission: true,\n);\n\n/// ...\n}\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#getdocumentthumbnail","title":"getDocumentThumbnail","text":"<p>Mirror of <code>DocumentsContract.getDocumentThumbnail</code></p> <p>Returns the image thumbnail of a given <code>uri</code>, if any (e.g documents that can show a preview, like images of gifs, <code>null</code> otherwise).</p> <pre><code>final Uint8List? imageBytes;\nfinal DocumentFile file = ...\n\nfinal Uri? rootUri = file.metadata?.rootUri;\nfinal String? documentId = file.data?[DocumentFileColumn.id] as String?;\n\nif (rootUri == null || documentId == null) return;\n\nfinal DocumentBitmap? bitmap = await getDocumentThumbnail(\nrootUri: rootUri,\ndocumentId: documentId,\nwidth: _size.width,\nheight: _size.height,\n);\n\nif (bitmap == null || !mounted) return;\n\nsetState(() =&gt; imageBytes = bitmap.bytes);\n\n/// Later on...\n@override\nWidget build(BuildContext context) {\nif (imageBytes == null) return Loading('My cool loading spinner');\n\nreturn Image.memory(imageBytes);\n}\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#documentfilecolumn","title":"DocumentFileColumn","text":"<p>Mirror of <code>DocumentsContract.Document.&lt;Column&gt;</code></p> <p>Use this class to refer to the SAF queryable columns in methods that requires granular/partial data fetch.</p> <p>For instance, in <code>listFiles</code> a large set can be returned, and to improve performance you can provide only the columns you want access/read.</p> <pre><code>/// Columns/Fields you want access. Android handle storage as database.\n/// Allow you specify only the fields you need to use, avoiding querying unnecessary data\nconst List&lt;DocumentFileColumn&gt; columns = &lt;DocumentFileColumn&gt;[\nDocumentFileColumn.displayName,\nDocumentFileColumn.size,\nDocumentFileColumn.lastModified,\nDocumentFileColumn.id,\nDocumentFileColumn.mimeType,\n];\n\nfinal Stream&lt;DocumentFile&gt; onNewFileLoaded = documentFileOfMyGrantedUri.listFiles(columns);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#delete","title":"delete","text":"<p>Mirror of <code>DocumentFile.delete</code></p> <p>Self explanatory, but just in case: delete the target uri (document file).</p> <pre><code>final Uri uri = ...\n\nawait delete(uri);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#createdirectory","title":"createDirectory","text":"<p>Mirror of <code>DocumentFile.createDirectory</code></p> <p>Self explanatory, but just in case: creates a new child document file that represents a directory given the <code>displayName</code> (folder name).</p> <pre><code>final Uri parentUri = ...\n\nawait createDirectory(parentUri, 'My Folder Name');\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#documentlength","title":"documentLength","text":"<p>Mirror of <code>DocumentFile.length</code></p> <p>Returns the length of this file in bytes. Returns 0 if the file does not exist, or if the length is unknown.</p> <pre><code>final Uri uri = ...\n\nfinal int? fileSize = await documentLength(uri);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#lastmodified","title":"lastModified","text":"<p>Mirror of <code>DocumentFile.lastModified</code></p> <p>Returns the time <code>DateTime</code> when this file was last modified. Returns <code>null</code> if the file does not exist, or if the modified time is unknown.</p> <pre><code>final Uri uri = ...\n\nfinal int? fileSize = await documentLength(uri);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#findfile","title":"findFile","text":"<p>Mirror of <code>DocumentFile.findFile</code></p> <p>Search through <code>listFiles()</code> for the first document matching the given display name, this method has a really poor performance for large data sets.</p> <pre><code>final Uri directoryUri = ...\n\nfinal DocumentFile? match = await findFile(directoryUri, 'Target File Name');\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#fromtreeuri","title":"fromTreeUri","text":"<p>Mirror of <code>DocumentFile.fromTreeUri</code></p> <p>Create a <code>DocumentFile</code> representing the document tree rooted at the given <code>Uri</code>.</p> <pre><code>final Uri uri = ...\n\nfinal DocumentFile? treeUri = fromTreeUri(uri);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#renameto","title":"renameTo","text":"<p>Mirror of <code>DocumentFile.renameTo</code></p> <p>Self explanatory, but just in case: rename the given document file given its uri and a new display name.</p> <pre><code>final Uri uri = ...\n\nawait renameTo(uri, 'New Document Name');\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#parentfile","title":"parentFile","text":"<p>Mirror of <code>DocumentFile.parentFile</code></p> <p>Returns the parent document file of a given document file (uri).</p> <p><code>null</code> if you do not have permission to see the parent folder.</p> <pre><code>final Uri uri = ...\n\nfinal DocumentFile? parentUri = await parentFile(uri);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#copy","title":"copy","text":"<p>Mirror of <code>DocumentsContract.copyDocument</code></p> <p>Copy the given <code>uri</code> to a new <code>destinationUri</code>.</p> <pre><code>final Uri uri = ...\nfinal Uri destination = ...\n\nfinal DocumentFile? copiedFile = await copy(uri, destination);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#alias-methods","title":"Alias methods","text":"<p>These APIs are only shortcuts/alias, that is, they do not call native code directly, these are just convenient methods.</p>"},{"location":"Usage/Storage%20Access%20Framework/#ispersisteduri","title":"isPersistedUri","text":"<p>Alias for <code>persistedUriPermissions</code></p> <p>Check if a given <code>Uri</code> is persisted/granted, that is, you have permission over it.</p> <pre><code>/// Can be any Uri\nfinal Uri maybeGrantedUri = ...\n\nfinal bool ensureThisIsGrantedUri = await isPersistedUri(maybeGrantedUri);\n\nif (ensureThisIsGrantedUri) {\nprint('I have permission over the Uri: $maybeGrantedUri');\n}\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#getdocumentcontentasstring","title":"getDocumentContentAsString","text":"<p>Alias for <code>getDocumentContent</code></p> <p>Read a document file from its uri by opening a input stream, reading its bytes and converting to <code>String</code>.</p> <pre><code>final Uri uri = ...\n\nfinal String? fileContent = await getDocumentContentAsString(uri);\n\nprint(fileContent);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#createfileasstring","title":"createFileAsString","text":"<p>Alias for <code>createFileAsBytes</code></p> <p>Convenient method to create a file using <code>content</code> as <code>String</code> instead <code>Uint8List</code>.</p> <pre><code>final Uri parentUri = ...\nfinal String fileContent = 'My File Content';\n\nfinal DocumentFile? createdFile = createFileAsString(\nparentUri,\nmimeType: 'text/plain',\ndisplayName: 'Sample File Name',\ncontent: fileContent,\n);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#writetofileasstring","title":"writeToFileAsString","text":"<p>Alias for <code>writeToFileAsBytes</code></p> <p>Convenient method to write to a file using <code>content</code> as <code>String</code> instead <code>Uint8List</code>.</p> <pre><code>final Uri documentUri = ...\nfinal String fileContent = 'My File Content';\n\n/// Write to a file using a [Uint8List] as file contents [bytes]\nfinal bool? success = writeToFileAsString(\ndocumentUri,\ncontent: fileContent,\nmode: FileMode.write,\n);\n\n/// Append to a file using a [Uint8List] as file contents [bytes]\nfinal bool? success = writeToFileAsBytes(\ndocumentUri,\ncontent: fileContent,\nmode: FileMode.write,\n);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#createfile","title":"createFile","text":"<p>Alias for <code>createFileAsBytes</code> and <code>createFileAsString</code></p> <p>Convenient method to create a file using <code>content</code> as <code>String</code> or <code>bytes</code> as <code>Uint8List</code>.</p> <p>You should provide either <code>content</code> or <code>bytes</code>, if both <code>bytes</code> will be used.</p> <pre><code>final Uri parentUri = ...\nfinal String fileContent = 'My File Content';\n\n/// Create a file using a [String] as file contents [content]\nfinal DocumentFile? createdFile = createFile(\nparentUri,\nmimeType: 'text/plain',\ndisplayName: 'Sample File Name',\ncontent: fileContent,\n);\n\n/// Create a file using a [Uint8List] as file contents [bytes]\nfinal DocumentFile? createdFile = createFile(\nparentUri,\nmimeType: 'text/plain',\ndisplayName: 'Sample File Name',\ncontent: Uint8List.fromList(utf8.encode(fileContent)),\n);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#writetofile","title":"writeToFile","text":"<p>Alias for <code>writeToFileAsBytes</code> and <code>writeToFileAsString</code></p> <p>Convenient method to write to a file using <code>content</code> as <code>String</code> or <code>bytes</code> as <code>Uint8List</code>.</p> <p>You should provide either <code>content</code> or <code>bytes</code>, if both <code>bytes</code> will be used.</p> <p><code>mode</code> represents the mode in which the file will be opened for writing. Use <code>FileMode.write</code> for truncating and <code>FileMode.append</code> for appending to the file.</p> <pre><code>final Uri documentUri = ...\nfinal String fileContent = 'My File Content';\n\n/// Write to a file using a [String] as file contents [content]\nfinal bool? success = writeToFile(\ndocumentUri,\ncontent: fileContent,\nmode: FileMode.write,\n);\n\n/// Append to a file using a [String] as file contents [content]\nfinal bool? success = writeToFile(\ndocumentUri,\ncontent: fileContent,\nmode: FileMode.append,\n);\n\n/// Write to a file using a [Uint8List] as file contents [bytes]\nfinal bool? success = writeToFile(\ndocumentUri,\ncontent: Uint8List.fromList(utf8.encode(fileContent)),\nmode: FileMode.write,\n);\n\n/// Append to a file using a [Uint8List] as file contents [bytes]\nfinal bool? success = writeToFile(\ndocumentUri,\ncontent: Uint8List.fromList(utf8.encode(fileContent)),\nmode: FileMode.append,\n);\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#external-apis-deprecated","title":"External APIs (deprecated)","text":"<p>These APIs are from external Android libraries.</p> <p>Will be moved to another package soon.</p>"},{"location":"Usage/Storage%20Access%20Framework/#child","title":"child","text":"<p>Mirror of <code>com.anggrayudi.storage.file.DocumentFile.child</code></p> <p>Get the direct child of the given uri. Can be used to verify if a file already exists and check for conflicts.</p> <pre><code>final Uri parentUri = ...\n\nfinal DocumentFile? childDocument = child(parentUri, 'Sample File Name');\n\nif (childDocument != null) {\n/// This child exists...\n} else {\n/// Doesn't exists...\n}\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#internal-types-classes","title":"Internal Types (Classes)","text":"<p>Internal type (class). Usually they are only to keep a safe typing and are not usually intended to be instantiated for the package user.</p>"},{"location":"Usage/Storage%20Access%20Framework/#documentfile","title":"DocumentFile","text":"<p>This class represents but is not the mirror of the original <code>DocumentFile</code>.</p> <p>This class is not intended to be instantiated, and it is only used for typing and convenient purposes.</p>"},{"location":"Usage/Storage%20Access%20Framework/#querymetadata","title":"QueryMetadata","text":"<p>This class wraps useful metadata of the source queries returned by the <code>DocumentFile</code>.</p> <p>This class is not intended to be instantiated, and it is only used for typing and convenience purposes.</p>"},{"location":"Usage/Storage%20Access%20Framework/#documentbitmap","title":"DocumentBitmap","text":"<p>This class represent the bitmap/image of a document.</p> <p>Usually the thumbnail of the document.</p> <p>Should be used to show a list/grid preview of a file list.</p> <p>See also <code>getDocumentThumbnail</code>.</p> <p>This class is not intended to be instantiated, and it is only used for typing and convenient purposes.</p>"},{"location":"Usage/Storage%20Access%20Framework/#extensions","title":"Extensions","text":"<p>These are most alias methods implemented through Dart extensions.</p>"},{"location":"Usage/Storage%20Access%20Framework/#uritodocumentfile-on-uri","title":"Uri.toDocumentFile on <code>Uri</code>","text":"<p>Alias for <code>DocumentFile.fromTreeUri(this)</code></p> <p>This method convert <code>this</code> uri to the respective <code>DocumentFile</code> (if exists, otherwise <code>null</code>).</p> <pre><code>final Uri uri = ...\n\nfinal DocumentFile? documentFile = uri.toDocumentFile();\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#uriopendocumentfile-on-uri","title":"Uri.openDocumentFile on <code>Uri</code>","text":"<p>Alias for <code>openDocumentFile(this)</code></p> <p>This method open the current uri in a third-part application through <code>ACTION_VIEW</code> intent.</p> <pre><code>final Uri uri = ...\n\nawait uri.openDocumentFile();\n</code></pre>"},{"location":"Usage/Storage%20Access%20Framework/#android-official-documentation","title":"Android Official Documentation","text":"<p>The Storage Access Framework official documentation is available here.</p> <p>All the APIs listed in this plugin module are derivated from the official docs.</p>"}]}